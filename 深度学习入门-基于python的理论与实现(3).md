[toc]
# 深度学习入门-基于python的理论与实现(3)
![](front.png)
## 第三章：神经网络
上一章学习了感知机。关于感知机，既有好消息，也有坏消息。好消息是，即便对于复杂的函数，感知机也隐含着能够表示它的可能性。即便是计算机进行的复杂处理，感知机（理论上）也可以将其表示出来。坏消息是，设定权重的工作，即确定合适的、能符合预期的输入与输出的权重，现在还是由人工进行的。

上一章中，我们结合与门、或门的真值表人工决定了合适的权重。神经网络的出现就是为了解决刚才的坏消息。具体地讲，**神经网络的一个重要性质是它可以自动地从数据中学习到合适的权重参数**。
### 3.1 从感知器到神经网络
#### 3.1.1 神经网络的例子
如图是一个神经网络：
![](nn.png)

如图所示。我们把最左边的一列称为**输入层**，最右边的一列称为**输出层**，中间的一列称为**中间层**。中间层有时也称为**隐藏层**。“隐藏”一词的意思是，隐藏层的神经元（和输入层、输出 层不同）肉眼看不见。

另外，这里把输入层到输出层依次称为第0层、第1层、第2层（层号之所以从0开始，是为了方便后面基于Python进行实现）。 图中，第0层对应输入层，第1层对应中间层，第2层对应输出层。

#### 3.1.2 复习感知器
![](perceptron.png)
如图的感知器接受$x_1$和$x_2$两个输入信号你，输出$y$。其数学公式如下：
$$y= \begin{cases}
0 & (b+w_1x_1+w_2x_2 \leq 0 )\\
1 & (b+w_1x_1+w_2x_2 > 0 )
\end{cases}$$

b是被称为偏置的参数，用于控制神经元被激活的容易程度；而$w_1$和$w_2$ 是表示各个信号的权重的参数，用于控制各个信号的重要性。 

在上图的网络中，偏置b并没有被画出来。如果要明确地表示出b，可以像下图这样做。

![](bias.png)

图中添加了权重为b的输入信号1。这个感知机将$x_1$、$x_2$、1三个信号作为神经元的输入，将其和各自的权重相乘后，传送至下一个神经元。在下一个神经元中，计算这些加权信号的总和。如果这个总和超过0，则输出1，否则输出0。

另外，由于偏置的输入信号一直是1， 所以为了区别于其他神经元，我们在图中把这个神经元整个涂成灰色。 

现在将上式改写成更加简洁的形式。为了简化上式，我们用一个函数来表示这种分情况的动作（超过0则输出1，否则输出0）。引入新函数 h(x)，将上式改写成下面的式子：
$$y=h(b+w_1x_1+w_2x_2)$$

$$h(x)= \begin{cases}
0 & (x \leq 0 )\\
1 & (x > 0 )
\end{cases}$$

第一个式中，输入信号的总和会被函数$h(x)$转换，转换后的值就是输出$y$。 然后第二个式所表示的函数$h(x)$，在输入超过0时返回1，否则返回0。因此， 第一个式子和第二个式子还有上面的式子做的是相同的事情。
#### 3.1.3 激活函数登场
刚才的$h(x)$函数会将输入信号的总和转换为输出信号，这种函数 一般称为激活函数（activation function）。如“激活”一词所示，激活函数的作用在于决定如何来激活输入信号的总和。 

### 3.2 激活函数
上一节表示的激活函数以阈值为界，一旦输入超过阈值，就切换输出。这样的函数称为“阶跃函数”。因此，可以说感知机中使用了阶跃函数作为 激活函数。也就是说，在激活函数的众多候选函数中，感知机使用了阶跃函数。 那么，如果感知机使用其他函数作为激活函数的话会怎么样呢？实际上，如果将激活函数从阶跃函数换成其他函数，就可以进入神经网络的世界了。下面就来介绍一下神经网络使用的激活函数。

#### 3.1 sigmoid函数
sigmoid函数：
$$h(x)=\frac{1}{1+e^{-x}}$$
神经网络中用sigmoid函数作为激活函数，进行信号的转换，转换后的信号被传送给下一个神经元。
#### 3.2.2 阶跃函数的实现

阶跃函数如下式：
$$h(x)= \begin{cases}
0 & (x \leq 0 )\\
1 & (x > 0 )
\end{cases}$$
当输入超过0时，输出1，否则输出0。可以像下面这样简单地实现阶跃函数。
```python
def step_function(x):
    if x>0:
        return 1
    else:
        return 0

```
这个实现简单、易于理解，但是参数x只能接受实数（浮点数）。也就是说，允许形如step_function(3.0)的调用，但不允许参数取NumPy数组，例如step_function(np.array([1.0, 2.0]))。为了便于后面的操作，我们把它修改为支持NumPy数组的实现。为此，可以考虑下述实现。
```python
def step_function(x):
    y=x>0
    return y.astype(np.int)

```
可以用astype()方法转换NumPy数组的类型。astype()方法通过参数指定期望的类型，这个例子中是np.int型。Python中将布尔型转换为int型后，True会转换为1n,False会转换为0。

#### 3.2.3 阶跃函数的图形

下面用图来表示上面定义的阶跃函数，为此需要使用matplotlib库。
```python
import numpy as np 
import matplotlib.pylab as plt
def step_function(x):    
    return np.array(x > 0, dtype=np.int)

x = np.arange(-5.0, 5.0, 0.1)
y = step_function(x) 
plt.plot(x, y)
plt.ylim(-0.1, 1.1) # 指定y轴的范围 
plt.show()
```    
np.arange(-5.0, 5.0, 0.1)在−5.0到5.0的范围内，以0.1为单位，生成 NumPy数组（[-5.0, -4.9, ..., 4.9]）。 step_function()以该NumPy数组为 参数，对数组的各个元素执行阶跃函数运算，并以数组形式返回运算结果。 对数组x、y进行绘图，结果如图所示。
![](jieyue.png)

如图，阶跃函数以0为界，输出从0切换为1（或者从1切换为0）。 它的值呈阶梯式变化，所以称为阶跃函数。

#### 3.2.4 sigmoid函数的实现

